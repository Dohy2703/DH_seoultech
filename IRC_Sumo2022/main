/* Jisung Yoon, Dohyeon Kim */
#include "mbed.h"
#include "GP2A.h"
#include "string"

#define middle_angle 100  // 서보모터 중앙값 판단

#define lift ir7>65000  // 검은 색 영역에서 들렸는지 판단 기준 

#define ir0In ir0<10000
#define ir1In ir1<50000
#define ir2In ir2<42000
#define ir3In ir3<10000
#define ir4In ir4<20000
#define ir5In ir5<10000
#define ir6In ir6<10000  //중앙 오
#define ir7In ir7<10000  // 중앙 왼
#define ir8In ir8<20000

#define ir0Out ir0>10000
#define ir1Out ir1>50000
#define ir2Out ir2>42000
#define ir3Out ir3>10000
#define ir4Out ir4>20000
#define ir5Out ir5>10000
#define ir6Out ir6>10000
#define ir7Out ir7>10000
#define ir8Out ir8>20000

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡUART, 시리얼 통신ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ//
Serial pc(USBTX,USBRX,9600);            // 시리얼 모니터 출력
RawSerial pc2(PC_12,PD_2,115200);       // 라즈베리파이 통신(RawSerial-인터럽트통신용)
Serial bt(PC_10, PC_11,9600);           // 블루투스 통신
char a[5]="****";                       //통신데이터

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡ시작 스위치(인터럽트)ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ//                          
InterruptIn btn(BUTTON1);    //인터럽트 활성화
InterruptIn btn2(PB_4, PullUp);    //인터럽트 활성화

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ센서, 모터ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ//
GP2A ps1(PC_3, 20, 150, 60, 0); // 앞 왼쪽
GP2A ps2(PC_1, 20, 150, 60, 0); // 앞 오른쪽
//GP2A ps3(PA_4, 20, 150, 60, 0); // 카메라 가운데 - 안씀
//GP2A ps4(PA_4, 20, 150, 60, 0); // 카메라 가운데 - 안씀
GP2A ps5(PC_5, 20, 150, 60, 0); // 뒤 오른쪽
GP2A ps6(PA_5, 20, 150, 60, 0); // 뒤 왼쪽

AnalogIn irPin0(PC_2);
AnalogIn irPin1(PC_0);
//AnalogIn irPin2(PB_0);
AnalogIn irPin2(PA_4);
AnalogIn irPin3(PA_1);
AnalogIn irPin4(PC_4);
AnalogIn irPin5(PB_1);
AnalogIn irPin6(PA_7);
AnalogIn irPin7(PA_6);
AnalogIn irPin8(PA_0); // 앞 가운데

PwmOut PWM1(PB_5);              // 왼쪽 PWM
PwmOut PWM2(PA_10);             // 오른쪽 PWM
DigitalOut dir1(D7), dir2(D8);  //왼쪽 바퀴가 앞으로 굴러가는게 dir1=0

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ함수원형ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ//
void free_go(int ang);  // ****기본적인 주행 코드*****(상대 밀기, 곡선 등등)

void go_straight();     // 전진(특수 상황)
void go_back();         // 후진(파란영역, 회피구동 종료 시)
void turn_left();       // 몸체 회전 - 왼쪽
void turn_right();      // 몸체 회전 - 오른쪽
void stop();            // 멈춤

void turning_right();   // 곡선주행(빨간영역) - 오른쪽
void turning_left();    // 곡선주행(빨간영역) - 왼쪽
void turn_left_input(float put);      // 몸체 회전 - 서보모터 각도에 따라 왼쪽
void turn_right_input(float put);     // 몸체 회전 - 서보모터 각도에 따라 오른쪽
void turn_right_slow(int error, float Pgain, float Dgain);         // 색 영역에 완전히 들어갔을 때 좌우
void turn_left_slow(int error, float Pgain, float Dgain);          // 색 영역에 완전히 들어갔을 때 좌우
void turning_right_blue();      // 파란색 영역으로 밀기
void turning_left_blue();       // 파란색 영역으로 밀기
void red_turning_right();       // 빨간색 영역으로 조금 들어갔을 때 구동
void red_turning_left();        // 빨간색 영역으로 조금 들어갔을 때 구동
void go_straight_slow();
void go_back_slow();
void go_straight_slow_plus();

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ타이머ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ//
Timer timer_pwm_inc;        //돌진 시 pwm 서서히 증가시킬 때 쓰는 타이머
Timer loop_time;            // 제어주기 측정
Timer timer_back_after;     // 후진 이후 가속
Timer timer_wait;           // wait 없앨려고
Timer timer_stop_turning;   // 파랑영역에서 계속 도는거랑 빨간 영역 주위 곡선 주행 계속하는거 방지
Timer timer_ir_frontIn_wait;// 파랑영역에서 계속 도는거랑 빨간 영역 주위 곡선 주행 계속하는거 방지
Timer timer_avoid;          // (회피구동) 
Timer timer_lift;           // (회피구동) 들린 시간 측정
Timer timer_send_p;         // p값 보낼 때 튀는거 방지
Timer watchdog_timer;       // 카메라 꺼짐 대응용 타이머
Timer timer_stop_turning_blue;
//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ센서ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ//
float ir0,ir1,ir2,ir3,ir4,ir5,ir6,ir7, ir8; // ir 센서
float psd1,psd2,psd3,psd4,psd5,psd6;        // psd 센서
float PWM1_1, PWM1_2, PWM2_1, PWM2_2;       // free_go 가속에 사용
float error_free_ang, prev_error_free_ang;  // freego에서 사용

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ플래그ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ//
bool IR_Front_In=false;            // 전방 ir (0,1,2,3) 중 하나라도 감지 시
bool IR_Back_In=false;             // 후방 ir (4,5) 중 하나라도 감지 시
bool IR_All_In=false;              // ir이 전부 빠졌을 때
bool IR_All_Out=false;             // ir이 전부 안빠짐
bool run_away = true;              // 회피구동 실행 여부 결정
bool turning_right_red = false;    // 전방 ir 걸렸을 때 몸체 회전하는 플래그(빨간영역)
bool turning_left_red = false;     // 전방 ir 걸렸을 때 몸체 회전하는 플래그(빨간영역)
bool turn_flag = true;             // 빨간영역 전방 ir 걸리면 몸체 회전
bool red_turning_right_soft = true;// 빨간영역에 살짝 걸리면(ir2) 곡선주행으로
bool red_turning_left_soft = true; // 빨간영역에 살짝 걸리면(ir1) 곡선주행으로
bool IR_Front_In_Turn = false;     // IR_Front_In일 때 회전하는 wait 플래그
bool Middle_In_Go_Back = false;    // 영역 안에서 들렸을 때
bool All_In_OFF = false;           // 영역 완전히 들어갔을 때 빠져나오는거 왔다갔다 안하게 하는 플래그
bool send_p = false;               // 정지 스위치
bool send_s = false;               // 시작 스위치
bool bt_mode = true;               // 정지 스위치 살짝 눌렀을 때 블루투스 ir값<->psd값 전환 
int ang=0,error_ang=0;       // ang:받아온 서보모터 각도, error_ang: 90과 ang의 차(절댓값)
float Pgain = (0.5/(90));    // 상대 몸체 맞추는 P게인
bool freego=false;              // 가속 관련
bool back_after = false;                // 후진 후 속도 0부터 시작
bool Remove_Wait=false;                 // (Wait 없애기)
bool All_In_Go_Back = false;            // (Wait 없애기)
bool IR_Front_In_Go_Back = false;       //(Wait 없애기)
bool IR_Front_In_Go_Back_Short = false; //(Wait 없애기)
bool IR_All_In_Short=false;             //(Wait 없애기)

bool lift_flag = false;            // (회피구동) 0.2초 이상 들렸을 때

bool IR_All_In_Blue_Out_Turn_Right_wait = false;
bool IR_All_In_Blue_Out_Turn_Left_wait = false;

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ스위치ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ//
void flip(){            //시작 스위치
    send_s = true;    
    dir1 = 0; dir2 = 0;  // 왼쪽
    PWM1 = 0.6; PWM2 = 0.6;
}

void flip2_fall(){           //정지 스위치 - 살짝 눌렀을 때     
    timer_send_p.start();
    if (bt_mode) bt_mode=false;
    else bt_mode = true;
}

void flip2_rise(){          //정지 스위치 - 꾹 눌렀을 때
    if (timer_send_p.read() > 1) {send_p = true;}
    timer_send_p.stop();
    timer_send_p.reset();
}




bool front_wait = false;
bool blue_back = true;
bool escape_blue = false;

bool blue_back_after = false;
bool lift_color_in = false;

bool wait_mode = true;
bool count_mode=true;

bool Wait_go_back = false;
bool Wait_go_straight = false;

bool ir_front_in_blue = false;
bool lift_condition = true;

int max_alpha=0;

char buf[5] = "";

int char_cnt = 0;

void onCharReceived(){
    if (pc2.readable()){
        a[char_cnt] = pc2.getc();
        char_cnt++;
    }
    if (char_cnt == 4) char_cnt = 0;
    watchdog_timer.reset();
}

bool wait_flag = true;


bool IR_All_In_Blue_Flag = false;        // 파란 영역에 빠진 거 판단 조건에 한 번만 들어가도록 하는 플래그
bool IR_All_In_Blue = false;  // 파란 영역에 완전히 들어감
bool Left_Wall = false;       // (파란영역) 왼쪽에 벽이 있음
bool Right_Wall = false;      // (파란영역) 오른쪽에 벽이 있음

bool IR_All_In_Blue_Wall_Turn = false;   // (파란영역) 벽까지 회전하는거 한번만 하게 하는 플래그
bool IR_All_In_Blue_Go_Back = false;     // (파란영역) 뒤로 후진하는 플래그
bool IR_All_In_Blue_Go_Straight = false; // (파란영역) 후진 후 잠시 앞으로 직진하는 플래그
bool IR_All_In_Blue_Go_Back_Second = false;   // (파란영역) 후진-> 직진->몸체회전->후진으로 영역 빠져나가는 플래그 
bool IR_All_In_Blue_Out_check_PSD = false;  // (파란영역) 영역 빠져나간 후 PSD 체크
bool IR_All_In_Blue_Out_Turn_Right = false;
bool IR_All_In_Blue_Out_Turn_Left = false;

bool IR_All_In_Blue_Wall_Wait_Right = false;   // (파란영역) 벽까지 몸체 회전하는 타이머 wait 플래그
bool IR_All_In_Blue_Wall_Wait_Left = false;   // (파란영역) 벽까지 몸체 회전하는 타이머 wait 플래그
bool IR_All_In_Blue_Go_Straight_Wait = false; // (파란영역) 후진 후 직진 타이머 wait 플래그 
bool IR_All_In_Blue_Go_Back_Second_Wait = false; // (파란영역) 후진->직진->몸체회전->"후진" 타이머 wait 플래그

bool IR_All_In_Blue_Short = false;
bool IR_All_In_Go_Back_long = false;
//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡmain문ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ//
//우선순위 : 전진(전방 IR 감지)>후진(후방 IR 감지)>서치(적이 카메라에서 사라짐)>그 외
int main()
{
    //pc2.putc('p');
    btn.fall(&flip);   //인터럽트
    btn2.fall(&flip2_fall);   //인터럽트
    btn2.rise(&flip2_rise);
    pc2.attach(&onCharReceived,Serial::RxIrq);

    PWM1.period_us(30);
    PWM2.period_us(30);

    float put_pwm, max_m = 0.6 , min_m = 0.4;   //put_pwm:몸체 회전 시 보내줄 pwm

    // rgb_sensor.enablePowerAndRGBC();    
    // rgb_sensor.setIntegrationTime( 50 );
    int rgb_readings[4];
    int rgb=0;

    //pc.printf("start! \n");
    bt.printf("start! \n");
    //while(!start){pc.printf("waiting..\n");}
    // wait_ms(200);
    watchdog_timer.start();
    //pc2.putc('s');              // 서보모터, 카메라 시작
    pc2.putc('R');

    dir1 = 0;
    dir2 = 0;
    PWM1 = 0.3;
    PWM2 = 0.3;
    //turn_right();
    // wait(0.9);
    // go_back();
    // wait(0.5);

    send_s = false;
    while(1){
        loop_time.reset();
        loop_time.start();
        //ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ센서값 읽기ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ//
        psd1=ps1.getDistance();    //왼쪽
        psd2=ps2.getDistance();    //오른쪽
        //psd3=ps3.getDistance();    //가운데
        //psd4=ps4.getDistance();     //앞 가운데
        psd5=ps5.getDistance();     //뒤 오른쪽
        psd6=ps6.getDistance();     //뒤 왼쪽

        // (왼쪽)  0  1  2  3  (오른쪽)
        //           7   6
        //         5        4
        ir0=irPin0.read_u16();      // 앞 왼쪽에서 첫 번째
        ir1=irPin1.read_u16();      // 앞 왼쪽에서 두 번째
        ir2=irPin2.read_u16();      // 앞 왼쪽에서 세 번째
        ir3=irPin3.read_u16();      // 앞 왼쪽에서 네 번째
        ir4=irPin4.read_u16();      // 뒤 왼쪽에서 두 번째
        ir5=irPin5.read_u16();      // 뒤 왼쪽에서 첫 번째
        ir6=irPin6.read_u16();      // 
        ir7=irPin7.read_u16();      // 

        ir8=irPin8.read_u16();

        if (send_p){
            PWM1 = 0.0;
            PWM2 = 0.0;
            pc2.putc('p');
            //pc.printf("%d \n", send_s);
            send_p = false;            
        }

        if (send_s){
            pc2.putc('s');
            send_s = false;
        }

        if(a[0]=='P'){
            PWM1=0;
            PWM2=0;
            continue;
        }
        
        if (bt_mode) bt.printf("%5.0f, %5.0f, %5.0f, %5.0f, %5.0f, %5.0f, %5.0f, %5.0f, %5.0f \n ", ir0/100, ir1/100,ir2/100, ir3/100, ir4/100, ir5/100, ir6/100, ir7/100, ir8/100);
        else bt.printf("%3.0f %3.0f %3.0f %3.0f %3.0f %3.0f \n", psd1, psd2, psd3, psd4, psd5, psd6);

        // if (watchdog_timer.read()>3){   // 카메라 끊겼을 때
        //     pc.printf("disconnected from PC");
        // }
        // ang = 60;
        //bt.printf("%3.0f %3.0f \n", psd5, psd6);

        //ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ통신 꼬였을 때ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ//
        //if (a[3] == '/'){   //송신 꼬였을 때
        if (a[3] == 'O' || a[3] == 'X'){   //송신 꼬였을 때
            char j=a[0];
            a[0]=a[1];
            a[1]=a[2];
            a[2]=a[3];
            a[3]=j;
        }
        //if (a[2] == '/'){   //송신 꼬였을 때
        if (a[2] == 'O' || a[2] == 'X'){   //송신 꼬였을 때
            char j=a[0];
            a[0]=a[1];
            a[1]=a[2];
            a[2]=a[3];
            a[3]=j;
        }
        //if (a[1] == '/'){   //송신 꼬였을 때
        if (a[1] == 'O' || a[1] == 'X'){   //송신 꼬였을 때
            char j=a[0];
            a[0]=a[1];
            a[1]=a[2];
            a[2]=a[3];
            a[3]=j;
        }

        //pc.printf("%c %c %c %d ",a[0], a[1], a[2], a[3]);    //  "/, 사라진값, 색영역으로 미는 값, 각도값"

        //ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ각도 변환ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ//
        ang = a[3];
        error_ang = ang - middle_angle;
        put_pwm = ((max_m-min_m)/90.0)*abs(error_ang) + min_m;
        
        //bt.printf("%5.0f, %5.0f, %5.0f, %5.0f, %5.0f, %5.0f, %5.0f, %5.0f, %5.0f \n ", ir0/100, ir1/100,ir2/100, ir3/100, ir4/100, ir5/100, ir6/100, ir7/100, ir8/100);
        //pc.printf("%5.0f, %5.0f \n", ir6, ir7);
        //pc.printf("%3.0f %3.0f %3.0f %3.0f ", psd1, psd2, psd3, psd4);  
        //pc.printf("%3.0f %3.0f \n", psd5, psd6);
        //bt.printf("%5.0f %5.0f \n", ir1, ir2); 


        //ㅡㅡㅡㅡㅡㅡㅡㅡㅡir을 통해 현재 상황 파악ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ//
        if (freego == false) {    // 가속 관련 타이머
            timer_pwm_inc.stop();
            timer_pwm_inc.reset();
        }
        freego = false;

        //bt.printf("%5.0f \n", ir7);
        // if (ir7>65000 && (psd5<50 || psd6<50) && (a[2]=='4' || a[2]=='5')){
        //     timer_lift.start();
        //     //bt.printf("lift_0 \n");

        //     if (timer_lift.read()>0.2) {
        //         lift_flag = true;
        //         //bt.printf("lift\n");
        //     }
        //     //lift_flag = true;
        // }
        // else {
        //     timer_lift.stop();
        //     timer_lift.reset();
        // }


        if (ir0In && ir1In && ir2In && ir3In && ir4In && ir5In && (psd5<50 || psd6<50) && ang > 30 && ang < 150 && IR_All_In_Blue_Flag){ // ang 체크
            //파란 영역에 완전히 빠졌을 때(판단)
            IR_All_In_Blue = true; 
            IR_All_In_Blue_Go_Back = true;     // 뒤로 후진하는거 한 번만 하도록
            IR_All_In_Blue_Go_Straight = true; // 후진 후 직진하는 거 한 번만 하도록
            IR_All_In_Blue_Go_Back_Second = true; // 후진 -> 직진 -> 몸체 회전 -> "후진" 
            IR_All_In_Blue_Wall_Turn = true;   // 벽쪽으로 회전 한 번만 하도록 
            IR_All_In_Blue_Out_check_PSD = true;   // 영역 빠져나간 후 PSD 체크


            IR_All_In_Blue_Flag = false; // 이 조건에 한 번만 걸리도록. (true 조건 : IR_All_Out)

            if ( (psd5<psd6 && psd5<50) ){        //체크 psd2번 값 찍어보기
                Right_Wall = true; // 오른쪽에 벽이 있다. -> 왼쪽으로 회전
                //bt.printf("Right_Wall_Detected");
                IR_All_In_Blue_Out_Turn_Left = true;
            }
            else if ( (psd5>psd6 && psd6<50) ){
                Left_Wall = true;   // 왼쪽에 벽이 있다. -> 오른쪽으로 회전
                IR_All_In_Blue_Out_Turn_Right = true;
                //bt.printf("Left_Wall_Detected");
            }
            else if ( (psd5<50) ){        //체크 psd2번 값 찍어보기
                Right_Wall = true; // 오른쪽에 벽이 있다. -> 왼쪽으로 회전
                //bt.printf("Right_Wall_Detected");
                IR_All_In_Blue_Out_Turn_Left = true;
            }
            else if ( (psd6<50) ){
                Left_Wall = true;   // 왼쪽에 벽이 있다. -> 오른쪽으로 회전
                IR_All_In_Blue_Out_Turn_Right = true;
                //bt.printf("Left_Wall_Detected");
            }
            else{
                //bt.printf("Right_Wall_Detected");
                Right_Wall = true;  // 디폴트 값 - 오른쪽에 벽이 있다.
                IR_All_In_Blue_Out_Turn_Left = true;
            }
        }

        if (ir0In && ir1In && ir2In && ir3In && ir4In && ir5In){  //전부 색영역 안일 때
            IR_All_In=true;    
            front_wait = true;  
        }
        else if (ir0Out && ir1Out && ir2Out && ir3Out && ir4Out && ir5Out) {  // 전부 색 영역 밖일 때(IR_All_Out)
            IR_All_Out = true;
            run_away = true;  // 회피구동 활성화
            front_wait = true;
            blue_back = true;
            escape_blue = false;
            blue_back_after = false;
            //lift_condition = true;
            All_In_OFF = false;
            lift_color_in = false;
            IR_All_In_Blue = false;
            Left_Wall = false;
            Right_Wall = false;
            IR_All_In_Blue_Flag = true;

            if (timer_stop_turning.read()>0.5){
                timer_stop_turning.stop();
                timer_stop_turning.reset();
            }
        }
        else if ((ir0In && ir1In && ir2In && ir3In) || (ir0In && ir1Out && ir2In && ir3In) || (ir0In && ir1In && ir2Out && ir3In) || (ir0In && ir1Out && ir2Out && ir3In) || (ir0Out && ir1In && ir2In && ir3Out && ir8In) ) {  // 전방 ir 모두 감지
            IR_Front_In=true;      //전방 ir 감지 시
        }
        // else if( ir6 < 42000 && ir6 > 3600 && ir4In && ir5In && !All_In_OFF) {
        else if( ir6 > 35000 && (ir4In || ir5In) && !All_In_OFF) { // *ir4in ir5in or 조건으로 수정
        // if( (ir6 > 3400 && IR_Back_In) || (ir4In && ir5In) ) {
            lift_color_in = true;
            //lift_condition = false;
            //All_In_OFF = true;
        }
        else if (ir0Out && ir1Out && ir2Out && ir3Out && (ir4In || ir5In)){ //뒤쪽 ir 색영역 진입
            IR_Back_In=true;
        }

        //ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ7ㅡㅡㅡㅡㅡㅡㅡ여기서 부터 구동 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ//
        if (Remove_Wait){     // wait 없애는 코드 - go_back 뒤에 wait 줄 때 
            //bt.printf("remove_wait");
            if (All_In_Go_Back){   // IR_All_In 일 때 뒤로 빠지는 코드
                //pc.printf("All_In_Go_Back");
                if (timer_wait.read()>1.3 || (ir6Out && ir7Out) || IR_All_Out){  // 탈출조건. 타이머 값이 wait의 값임
                    Remove_Wait = false;
                    All_In_Go_Back=false;
                    timer_wait.stop();
                    timer_wait.reset();
                    back_after = true;
                    timer_back_after.reset();
                }
            }

            else if (IR_Front_In_Go_Back_Short){
                //pc.printf("Front_In_Go_Back_short");
                if (timer_wait.read()>0.3 || !IR_Front_In || ir6Out && ir7Out){
                    IR_Front_In_Go_Back_Short = false;
                    Remove_Wait = false;
                    timer_wait.stop();
                    timer_wait.reset();
                    back_after = true;
                    timer_back_after.reset();
                }
            }
            else if (IR_Front_In_Turn){
                //pc.printf("IR_Front_In_Turn");
                if (timer_wait.read()>0.4 || !IR_Front_In){
                    IR_Front_In_Turn = false;
                    Remove_Wait = false;
                    timer_wait.stop();
                    timer_wait.reset();
                }
            }
            else if (IR_All_In_Short){
                //bt.printf("IR_ALL_IN_SHORT");
                if (timer_wait.read()>0.4){
                    IR_All_In_Short = false;
                    Remove_Wait = false;
                    timer_wait.stop();
                    timer_wait.reset();
                    blue_back = false;
                    //bt.printf("IR_All_In_Short \n");
                }
            }
            else if (IR_All_In_Blue_Short){
                //bt.printf("IR_ALL_IN_SHORT");
                if (timer_wait.read()>0.3){
                    IR_All_In_Blue_Short = false;
                    Remove_Wait = false;
                    timer_wait.stop();
                    timer_wait.reset();
                    //bt.printf("IR_All_In_Short \n");
                }
            }
            else if (Middle_In_Go_Back){
                //pc.printf("Middle_In_Go_Back");
                if (timer_wait.read()>0.5){  // 확인해보기
                    Middle_In_Go_Back = false;
                    Remove_Wait = false;
                    timer_wait.stop();
                    timer_wait.reset();
                    lift_color_in = false;
                    All_In_OFF = true;
                    back_after = true;
                    timer_back_after.reset();
                }
            }
            else if (Wait_go_back) {
                if(timer_wait.read()>1) {
                    Remove_Wait = false;
                    timer_wait.stop();
                    timer_wait.reset();
                    count_mode=false;
                }
            }

            else if (ir_front_in_blue){
                if(timer_wait.read()>0.2) {
                    Remove_Wait = false;
                    timer_wait.stop();
                    timer_wait.reset();
                    ir_front_in_blue=false;
                    back_after = true;
                    timer_back_after.reset();
                }
            }

            else if (Wait_go_straight) {
                if(timer_wait.read()>0.8) {
                    Remove_Wait = false;
                    timer_wait.stop();
                    timer_wait.reset();
                    count_mode=true;
                }
            }
            else if (IR_All_In_Blue_Wall_Wait_Right){     // 파란영역에 모두 빠졌을 때 왼쪽으로 회전하는 wait
                //if(timer_wait.read()>0.3 || psd6<35){
                if(timer_wait.read()>0.4){
                    Remove_Wait =false;
                    timer_wait.stop();
                    timer_wait.reset();
                    IR_All_In_Blue_Wall_Wait_Right = false;
                }
            }
            else if (IR_All_In_Blue_Wall_Wait_Left){     // 파란영역에 모두 빠졌을 때 오른쪽으로 회전하는 wait
                //if(timer_wait.read()>0.3 || psd5<35){
                if(timer_wait.read()>0.4){
                    Remove_Wait =false;
                    timer_wait.stop();
                    timer_wait.reset();
                    IR_All_In_Blue_Wall_Wait_Left = false;
                }
            }
            else if (IR_All_In_Blue_Go_Straight_Wait){   // 파란 영역에 모두 빠졌을 때 후진 후 잠깐 앞으로 가는 wait 
                if (timer_wait.read()>0.2 || ir8Out){
                    Remove_Wait =false;
                    timer_wait.stop();
                    timer_wait.reset();
                    IR_All_In_Blue_Go_Straight_Wait = false;
                }
            }
            else if (IR_All_In_Blue_Go_Back_Second_Wait){
                if (timer_wait.read()>1 || (ir8Out) ){
                    Remove_Wait =false;
                    timer_wait.stop();
                    timer_wait.reset();
                    IR_All_In_Blue_Go_Back_Second_Wait = false;
                }
            } 
            else if(IR_All_In_Go_Back_long) {
                if(timer_wait.read()>2 || (ir0Out && ir1Out && ir2Out && ir3Out && ir4Out && ir5Out) ) {
                    Remove_Wait = false;
                    timer_wait.stop();
                    timer_wait.reset();
                    IR_All_In_Go_Back_long = false;
                }
            }
            else if (IR_All_In_Blue_Out_Turn_Right_wait){
                if (timer_wait.read()>2 || (ir0In && ir5In) ) {
                    Remove_Wait = false;
                    timer_wait.stop();
                    timer_wait.reset();
                    IR_All_In_Blue_Out_Turn_Right_wait = false;
                }
            }
            else if (IR_All_In_Blue_Out_Turn_Left_wait){
                if (timer_wait.read()>0.5 || (ir3In && ir4In) ) {
                    Remove_Wait = false;
                    timer_wait.stop();
                    timer_wait.reset();
                    IR_All_In_Blue_Out_Turn_Left_wait = false;
                }
            }
        }



// 검은색 영역에서 들려씅ㄹ 때 else if문으로 작성
//--------------------------------여기서부터 구동------------------------------//
        else if (IR_All_In_Blue && !All_In_OFF){   // 파란 영역 All_In(동작)
            run_away = false;            
            //bt.printf("IR_All_In_Blue - ");            
            if (IR_All_In_Blue_Go_Back){          // 벽 -> "후진" -> 직진 -> 90도 회전
                // go_back();
                dir1 = 1; dir2 = 0;
                PWM1 = 0.4; PWM2 = 0.4;
                Remove_Wait=true;
                IR_All_In_Blue_Short = true;
                IR_All_In_Blue_Go_Back = false;   // 뒤로 한번만 후진하도록.
                timer_wait.start();
                //bt.printf("IR_All_In_Blue_Go_Back \n");
            }
            else if (IR_All_In_Blue_Go_Straight){ // 벽 -> 후진 -> "직진" -> 90도 회전
                dir1=0;dir1=1;                      //직진
                PWM1=0.2;PWM2=0.2;                  //속도
                Remove_Wait=true;
                timer_wait.start();
                IR_All_In_Blue_Go_Straight_Wait = true;
                IR_All_In_Blue_Go_Back = false; 
                IR_All_In_Blue_Go_Straight = false;
                //bt.printf("IR_All_In_Blue_Go_Straight \n");
            }
            else if (a[2] == '4' || a[2]=='5'){
                IR_All_In_Blue = false;
                All_In_OFF = true;
                timer_stop_turning_blue.stop();
                timer_stop_turning_blue.reset();
                timer_back_after.reset();
            }
            else if (Left_Wall && IR_All_In_Blue_Wall_Turn){ // 왼쪽 벽 -> 후진 -> 직진 -> "왼쪽으로 90도 회전"
                turn_right();  
                timer_wait.start();
                Remove_Wait = true;
                IR_All_In_Blue_Wall_Wait_Left = true;
                IR_All_In_Blue_Wall_Turn = false;
                //bt.printf("Left_Wall && IR_All_In_Blue_Wall_Turn \n");
            }
            else if (Right_Wall && IR_All_In_Blue_Wall_Turn){ // 오른쪽 벽 -> 후진 -> 직진 -> "오른쪽으로 90도 회전"
                turn_left();
                timer_wait.start();
                Remove_Wait = true;
                IR_All_In_Blue_Wall_Wait_Right = true;
                IR_All_In_Blue_Wall_Turn = false;
                //bt.printf("Right_Wall && IR_All_In_Blue_Wall_Turn \n");
            }
            else if (IR_All_In_Blue_Go_Back_Second){ // 벽 -> 후진 -> 직진 -> 90도 회전 -> "후진" (색 영역 빠져나가기)
                go_straight();
                Remove_Wait=true;
                IR_All_In_Blue_Go_Back_Second_Wait = true;
                IR_All_In_Blue_Go_Back_Second = false;   // 뒤로 한번만 후진하도록.
                timer_wait.start();
                //bt.printf("IR_All_In_Blue_Go_Back_Second \n");
            }
            // else if (psd6<50 && IR_All_In_Blue_Out_check_PSD){  // 어느쪽으로 돌 건지 판단
            //     IR_All_In_Blue_Out_Turn_Right = true;
            //     IR_All_In_Blue_Out_check_PSD = false;
            //     bt.printf("psd6<30 && IR_All_In_Blue_Out_check_PSD \n");
            // }
            // else if (psd5<50 && IR_All_In_Blue_Out_check_PSD){  // 어느 쪽으로 돌 건지 판단
            //     IR_All_In_Blue_Out_Turn_Left = true;
            //     IR_All_In_Blue_Out_check_PSD = false;
            //     bt.printf("psd5<30 && IR_All_In_Blue_Out_check_PSD \n");
            // }
            else if (IR_All_In){
                IR_All_In_Blue = false;
                timer_stop_turning_blue.stop();
                timer_stop_turning_blue.reset();
            }
            else if (IR_All_In_Blue_Out_Turn_Right){    // 벽 -> 후진 -> 직진 -> 90도 회전 -> 후진 -> "회전"
                dir1=1; dir2=1;
                PWM1 = 0.3;PWM2 = 0.3;
                timer_wait.start();
                Remove_Wait=true;
                IR_All_In_Blue_Out_Turn_Right = false;
                IR_All_In_Blue_Out_Turn_Right_wait = true;
                //bt.printf("IR_All_In_Blue_Out_Turn_Right && ir1In \n");
            }
            else if (IR_All_In_Blue_Out_Turn_Left){  // 벽 -> 후진 -> 직진 -> 90도 회전 -> 후진 -> "회전"
                // dir1=0;dir2=1;
                // PWM1=0.8;PWM2 = 0;
                dir1 = 0; dir2 = 0;
                PWM1 = 0.3;PWM2 = 0.3;
                timer_wait.start();
                Remove_Wait=true;
                IR_All_In_Blue_Out_Turn_Left = false;
                IR_All_In_Blue_Out_Turn_Left_wait = true;
                //bt.printf("IR_All_In_Blue_Out_Turn_Left && ir2In \n");
            }
            else if ( (a[2]=='1' || a[2]=='2' || a[2]=='3' || ang<25 || ang>150) && timer_stop_turning_blue.read()<6 ){ // ang 값 나중에 수정
                stop();
                timer_stop_turning_blue.start();
                IR_All_In_Blue_Out_Turn_Left = false;
                IR_All_In_Blue_Out_Turn_Right = false;
                //bt.printf("Stop \n");
            }
            else if ( (a[2]=='4' || a[2]=='5') && ang>25 && ang<150 && timer_stop_turning_blue.read()<6 ){
                timer_stop_turning_blue.start();
                IR_All_In_Blue_Out_Turn_Left = false;
                IR_All_In_Blue_Out_Turn_Right = false;
                IR_All_In_Blue = false;
                //bt.printf("Blue Out \n");
            }
            else if(timer_stop_turning_blue.read()>6)  {
                IR_All_In_Blue = false;
                timer_stop_turning_blue.stop();
                timer_stop_turning_blue.reset();
                //bt.printf("Blue Out - else \n");
            }
            // 탈출 조건 -> 
        }

        else if (!IR_All_In_Blue && IR_All_In && !All_In_OFF) {                    //전부 색 영역에 들어갔을 때 구동
            run_away = false;
                escape_blue = true;
                timer_stop_turning.start();

            
                if( (ang < (middle_angle-20) || ang > (middle_angle+20)) && !blue_back_after && timer_stop_turning.read()<1.5) {
                    run_away = false;
                    if(error_ang>0)
                        turn_right_slow(error_ang, Pgain, 0);
                    else if(error_ang<0)
                        turn_left_slow(-error_ang, Pgain, 0);
                    turn_flag = true;
                    //pc.printf("all_in_turn");
                }

                else if (blue_back && timer_stop_turning.read()<1.5){
                    go_back();
                    back_after=true;
                    blue_back_after = true;
                    // dir1 = 1;
                    // dir2 = 0;
                    // PWM1 = 0.3;
                    // PWM2 = 0.3;
                    Remove_Wait=true;
                    IR_All_In_Go_Back_long=true;
                    timer_wait.start();
                    blue_back = false;
                    //pc.printf("blue_go_back");
                }

                // else if((ang>(middle_angle-60) && ang<(middle_angle+60)) && (!blue_back || timer_stop_turning.read()>1.5) ) {
                //     free_go(ang);
                //     All_In_OFF = true;
                //     run_away = false;
                //     //pc.printf("all_in_free_go");
                // }
                // else {
                //     go_back();
                //     timer_wait.start();
                //     Remove_Wait = true;
                //     IR_All_In_Short = true;
                // }
        }
        
        // ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ//
        else if (All_In_OFF){
            free_go(ang);
            // if (IR_All_Out){
            //     All_In_OFF = false;
            // }
            //pc.printf("all_in_off_free_go");
        }

        else if (psd1<35 && psd2<35 && (ang<25 || ang>160 || a[1]=='L' || a[1]=='R') && a[0]=='X'){ //벽에 박는거 방지
            go_back();
            Remove_Wait = true;
            ir_front_in_blue = true;
            timer_wait.start();
        }

        else if (lift_color_in && !All_In_OFF && (a[2] == '5' || a[2]=='4')){
            go_back();
            Remove_Wait = true;
            Middle_In_Go_Back = true;
            timer_wait.start();
            lift_color_in = false;
            //pc.printf("go_back_lift_color_in");
        }

        // else if(ir0Out && ir1Out && ir2Out && ir3Out && ir4Out && ir5Out && (ir6In || ir7In)) {
        //     go_back();
        //     Remove_Wait = true;
        //     Middle_In_Go_Back = true;
        //     timer_wait.start();
        // }


//////////////////이창민 수정/////////////////////////////////
        else if( ( (ir1In && ir2In) || IR_Front_In)&& a[0]=='O' && (( (ang > 45 && ang < 145) && (a[2]=='3' || a[2]=='4' || a[2]=='5') && (ir4Out || ir5Out) ))) {  // ang이 너무 치우쳐진거 같음.
            //bt.printf("chanmin \n");
            back_after = true;
            timer_back_after.reset();
            run_away = false;

            if(ir4In || ir5In) {
                go_back_slow();
                timer_wait.start();
                Remove_Wait = true;
                IR_Front_In_Go_Back_Short = true;
            }
            
            else if (ir6Out&&ir7Out){
                timer_ir_frontIn_wait.stop();
                timer_ir_frontIn_wait.reset();
                go_straight_slow_plus();
                }
            else if (ir7In){
                timer_ir_frontIn_wait.stop();
                timer_ir_frontIn_wait.reset();
                go_back_slow();
                }
            turn_flag = false;
            // 창민이의 빨간영역 빠졌을 때 상대 따라가는 코드
        }
// /////////////////////////////////////여기까지다
        else if( (ir1In && ir2In || IR_Front_In)  && a[0]=='X' && (( (ang > 45 && ang < 145) && (a[2]=='2' || a[2]=='3' || a[2]=='4' || a[2]=='5') && (ir4Out || ir5Out) ))) {  // ang이 너무 치우쳐진거 같음. 파란색 영역 빠졌을 때
            //bt.printf("chanmin \n");
            back_after = true;
            timer_back_after.reset();
            run_away = false;

            if(ir4In || ir5In) {
                go_back_slow();
                timer_wait.start();
                Remove_Wait = true;
                IR_Front_In_Go_Back_Short = true;
            }
            
            else if (ir6Out&&ir7Out){
                timer_ir_frontIn_wait.stop();
                timer_ir_frontIn_wait.reset();
                go_straight_slow_plus();
            }
            else if (ir7In){
                timer_ir_frontIn_wait.stop();
                timer_ir_frontIn_wait.reset();
                go_back_slow();
            }
            turn_flag = false;
            // 창민이의 빨간영역 빠졌을 때 상대 따라가는 코드
        }


        else if(!IR_Front_In && (ir6In || ir7In) && ir4Out && ir5Out && (a[2]=='4' || a[2]=='5') ) { // lift2
            go_back();
            Remove_Wait = true;
            Middle_In_Go_Back = true;
            timer_wait.start();
        }

        // frontir의 while을 대체하는 부분// 
        else if (turning_right_red){
            //pc.printf("turn_right");
            if(ir8In && ir2Out) {
                dir1 = 0;
                dir2 = 1;
                PWM1 = 0.8;
                PWM2 = 0.5;
                //red_turning_right();
            }
            
            else if (ir8Out){
                turning_right_red = false;
            }
            else {
                dir1 = 0;
                dir2 = 0;
                PWM1 = 0.7;
                PWM2 = 0.3;
            }
        }
        else if (turning_left_red){
            //pc.printf("turn_left");
            if(ir8In && ir1Out) {
                dir1 = 0;
                dir2 = 1;
                PWM1 = 0.5;
                PWM2 = 0.8;
            }
            else if (ir8Out){
                turning_left_red = false;
            }
            else {
                dir1 = 1;
                dir2 = 1;
                PWM1 = 0.3;
                PWM2 = 0.8;
            }
        }

        else if(ir0In && ir5In && ang < (middle_angle-20) && !IR_Back_In && a[0]=='O') { //곡선주행 - 1. 빨간 영역, 왼쪽 감지
            // timer_red_turning.start();
            run_away = false;
            //if (a[2] != '3'){   // 평상 시
                // if (ir3In || ir6In) {  // 수정 
            if (ir8In){
                dir1=0;
                dir2=1;
                PWM1 = 0.7;
                PWM2 = 0.45;
            }
            else if (ir1In) {  // 수정 
                dir1=0;
                dir2=1;
                PWM1 = 0.4;
                PWM2 = 0.97;
                //pc.printf("red_turning_right");
            }
            else {
                turning_left(); //왼쪽 방향으로 곡선 주행
            }
            turn_flag = false;
        }

        else if(ir0Out && ir1In && ir5In && ang < (middle_angle-20) && !IR_Back_In && a[0]=='O') { //곡선주행 - 1. 빨간 영역, 왼쪽 감지
            // timer_red_turning.start();
            run_away = false;
            //if (a[2] != '3'){   // 평상 시
                // if (ir3In || ir6In) {  // 수정 
            if (ir8In){
                dir1=0;
                dir2=1;
                PWM1 = 0.7;
                PWM2 = 0.45;
            }
            // else if (ir1In) {  // 수정 
            //     dir1=0;
            //     dir2=1;
            //     PWM1 = 0.4;
            //     PWM2 = 0.97;
            //     //pc.printf("red_turning_right");
            // }
            else {
                // turning_left(); //왼쪽 방향으로 곡선 주행
                dir1=0;
                dir2=1;
                PWM1 = 0.4;
                PWM2 = 0.97;
            }
            turn_flag = false;
        }



        //else if(ir3In && ir4In && ang > 100 && !IR_Back_In) {  //곡선주행 - 2. 빨간영역, 오른쪽감지
        else if(ir3In && ir4In && ang > (middle_angle+20) && !IR_Back_In && a[0]=='O') {  //곡선주행 - 2. 빨간영역, 오른쪽감지
            // timer_red_turning.start();
            run_away = false;
            //if (a[2]!='3'){
                // if (ir0In || ir7In) {
            if (ir8In){
                dir1=0;
                dir2=1;
                PWM1 = 0.4;
                PWM2 = 0.7;
            }
            else if (ir2In) {
                //turning_left();
                //pc.printf("red_turning_left");
                dir1=0;
                dir2=1;
                PWM1 = 0.97;
                PWM2 = 0.4;
            }
            else {
                    turning_right(); //왼쪽 방향으로 곡선 주행
            }
            turn_flag = false;
        }

        else if(ir3Out && ir2In && ir4In && ang > (middle_angle+20) && !IR_Back_In && a[0]=='O') {  //곡선주행 - 2. 빨간영역, 오른쪽감지
            // timer_red_turning.start();
            run_away = false;
            //if (a[2]!='3'){
                // if (ir0In || ir7In) {
            if (ir8In){
                dir1=0;
                dir2=1;
                PWM1 = 0.4;
                PWM2 = 0.7;
            }
            // else if (ir2In) {
            //     //turning_left();
            //     //pc.printf("red_turning_left");
            //     dir1=0;
            //     dir2=1;
            //     PWM1 = 0.97;
            //     PWM2 = 0.4;
            // }
            else {
                    // turning_right(); //왼쪽 방향으로 곡선 주행
                dir1=0;
                dir2=1;
                PWM1 = 0.97;
                PWM2 = 0.4;
            }
            turn_flag = false;
        }

        else if(ir1In && ir2Out && turn_flag==true && !IR_Back_In && a[0]=='O') {   //빨간색 살짝 걸쳤을 때 곡선 주행으로 회피
            red_turning_right();
            run_away = false;
            red_turning_left_soft = false;
            // Avoid_Back_Wall_R();
        }

        //else if(ir2In && ir3In && turn_flag==true && red_turning_bool && !IR_Back_In){
        else if(ir1Out && ir2In && turn_flag==true && !IR_Back_In && a[0]=='O'){
            red_turning_left();
            run_away = false;
            red_turning_right_soft = false;
            // Avoid_Back_Wall_L();
        }

        // FRONTIR(ang)을 대체하는 코드-2
        else if(IR_Front_In && (a[2]=='1' || a[2]=='2') && turn_flag && !IR_Back_In) {
            // FRONTIR(ang);
            run_away = false;
            if(ang>=100 && red_turning_right_soft){
                turning_right_red = true;   // 빨간색 영역을 오른쪽으로 회전함 -> 트루로 만들어줌
                turn_flag = false;
            }
            else if (ang<100 && red_turning_left_soft){
                turning_left_red = true; // 빨간색 영역을 왼쪽으로 회전함 -> 트루로 만들어줌
                turn_flag = false;
            }
            else {
                turning_right_red = true; // 빨간색 영역을 왼쪽으로 회전함 -> 트루로 만들어줌
                turn_flag = false;
            }
            PWM1 = 0.3;
            PWM2 = 0.3;
        }

        else if( (a[2]=='4' || a[2]=='5') && a[1]=='r') {
            dir1=0;
            dir2=1;
            PWM1=1;
            PWM2=0.7;
        }

        else if((a[2]=='4' || a[2]=='5') && a[1]=='l') {
            dir1=0;
            dir2=1;
            PWM1=0.7;
            PWM2=1;
        }

        else if( a[2] != '0' && ang>(middle_angle-60) && ang<(middle_angle+60)) {   //free_go 코드
        // 색영역 크기가 크고 각도가 40에서 140사이 이면
            if(IR_Front_In) {
                turn_flag = true;
            }
            else {
                free_go(ang);
                //pc.printf("free_go");   
            }
        }

        //ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ로봇 바디 턴ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ//
        else{
            if (a[1]=='0' || a[2]=='0') turn_right();
            else if(a[1]=='R' && IR_All_Out){
                turn_right();
                //pc.printf("turn_right");
            }
            else if(a[1]=='L' && IR_All_Out){
                turn_left();
                //pc.printf("turn_right");
            }
            else if (ang > (middle_angle+30) && IR_All_Out) {
                turn_right_input(put_pwm);
                //b.append("cmr_turn_right");
            }
            else if(ang < (middle_angle-30) && IR_All_Out) {
                turn_left_input(put_pwm);
                //b.append("cmr_turn_left");
            }
            else if(IR_All_Out){
                go_straight();
                //b.append("cmr_go_straight");
            }

            else {
                turn_right();
            }
        }

        // prev_a0=a[0];
        // prev_psd_change = psd_change;
        // pc.printf(" %s ", b.c_str());

        //pc.printf("%3.0f %3.0f %3.0f %3.0f %3.0f %3.0f \n", psd1, psd2, psd3, psd4, psd5, psd6);  

////////////////////////////////플래그 초기화 //////////////////////////////////////////////////

        IR_Front_In=false;            // 전방 ir (0,1,2,3) 중 하나라도 감지 시
        IR_Back_In=false;             // 후방 ir (4,5) 중 하나라도 감지 시

        IR_All_In=false;           // ir이 전부 빠졌을 때

        if(ir0Out && ir1Out && ir2Out && ir3Out && ir4Out && ir5Out){
            run_away = true;
            turn_flag = true;
            red_turning_left_soft = true;
            red_turning_right_soft = true;
        }

/////////////////////////////////////////////////////////////////////////////////////////////////
        //블루투스 통신 시리얼
        // if (bt_mode) bt.printf("%5.0f, %5.0f, %5.0f, %5.0f, %5.0f, %5.0f, %5.0f, %5.0f, %5.0f \n ", ir0/100, ir1/100,ir2/100, ir3/100, ir4/100, ir5/100, ir6/100, ir7/100, ir8/100);
        // else bt.printf("%3.0f %3.0f %3.0f %3.0f %3.0f %3.0f \n", psd1, psd2, psd3, psd4, psd5, psd6);
        //pc.printf("%5.0f %5.0f %5.0f %5.0f %5.0f %5.0f %5.0f %5.0f %5.0f \n", ir0, ir1, ir2, ir3, ir4, ir5, ir6, ir7, ir8);



        // bt.printf("%5.0f %5.0f \n", ir6/100, ir7/100);
        //pc.printf("%3.0f, %3.0f ,%3.0f, %3.0f, %3.0f ", psd1, psd2, psd4, psd5, psd6);
        //pc.printf("%d ", rgb);
        //pc.printf("%5.0f %5.0f \n", ir6, ir7);
        
        //pc.printf("%5.0f \n", ir8);
        //pc.printf("%3.0f %3.0f \n", psd1, psd2);
        
        //pc.printf("%3.0f %3.0f ", psd5, psd6);

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ제어주기 측정ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ//
        loop_time.stop();
        int alpha = loop_time.read_us(); 
        //pc.printf("loop_time : %d \n", alpha);
        //pc.printf("\n");7
        // // while(alpha<50){  //제어주기 고정
        // //     alpha = loop_time.read_ms(); 
        // // }
        

        //pc.printf("fixed_loop_time : %d \n", alpha);

        // if (max_alpha<alpha) max_alpha=alpha;  //최대 루프타임 측정
        // pc.printf("max_loop_time : %d \n", max_alpha);

        //bt.printf("%d \n", alpha);
        
    }
}


// //ㅡㅡㅡㅡㅡㅡㅡㅡㅡ일반적인 주행ㅡㅡㅡㅡㅡㅡㅡㅡ//
void go_straight(){
    dir1 = 0;
    dir2 = 1;
    PWM1 = 0.6;
    PWM2 = 0.6;
}

float Kd=1.0;

void free_go(int ang){
    //bt.printf("free_go \n");
    freego = true;
    dir1=0;
    dir2=1;
    error_free_ang = 0;
    error_free_ang = abs(float(ang - middle_angle)/100.0);
    //pc.printf("%f ", error_free_ang);
    if (back_after){
        timer_back_after.start();   
        //
        float put = 0.2+6*timer_back_after.read()/10.0;
        //


        // if (ir0In || ir1In || ir2In || ir3In || ir4In || ir5In){   // ir 중 하나라도 빠짐
        //     back_after = false;
        //     timer_back_after.stop();
        //     timer_back_after.reset();
        //     //b.append("any_in");
        // }  // 가속 타이머 오류 발생하는 경우를 방지해줌!!
        //
        if (put>=0.7) {
            put=0.7;
            back_after = false;
        }
        if (ang >= middle_angle){
            PWM1 = put;
            if(error_free_ang > 0.4) {
                //PWM2 = 0.2;
                PWM2_2 = put;
                if (PWM2_2 >= 0.2) PWM2_2 = 0.2;
                PWM2 = PWM2_2;
            }
            else {
                PWM2_1 = put - (error_free_ang);
                if (PWM2_1 <= 0) PWM2_1 = 0;
                PWM2 = PWM2_1;
                //pc.printf("free_go_in_turn_right");
            }
        }
        if (ang < middle_angle){
            PWM2 = put;
            if(error_free_ang > 0.4) {
                PWM1_2 = put;
                if (PWM1_2 >= 0.2) PWM1_2 = 0.2;
                PWM1 = PWM1_2;
            }
            else {
                PWM1_1 = put - (error_free_ang);
                if (PWM1_1 <= 0) PWM1_1 = 0;
                PWM1 = PWM1_1;
                //pc.printf("free_go_in_turn_right");
            }    
        }
    }
    else if (a[2]=='2' || a[2]=='3'){
        timer_pwm_inc.start();
        if(ang > middle_angle){         // 오른쪽으로 밀어야 함
            
            if(error_free_ang > 0.4) {
                PWM2 = 0;
            }
            else {  //error_free_ang 범위 0.4~0~0.4, 0.7/0.4=1.75(PGain)
                // PWM2 = 0.7 - (error_free_ang)+ Kd*(prev_error_free_ang-error_free_ang)/50.0;  //오버슛 발생시 시도해보기
                PWM2 = 0.7 - 1.75*error_free_ang;
                //pc.printf("free_go_in_turn_right");
            }
            PWM1 = 0.7;
        }    
        else if(ang < middle_angle){        //왼쪽으로 말어야함
            if(error_free_ang > 0.4){
                PWM1 = 0;
            }
            else {
                // PWM1 = 0.7 - (error_free_ang)+ Kd*(prev_error_free_ang-error_free_ang)/50.0;
                PWM1 = 0.7 - 1.75*error_free_ang;
                //pc.printf("free_go_in_turn_left");
            }
            PWM2 = 0.7;
        }
    //ㅡㅡㅡㅡㅡㅡㅡㅡㅡ가속 코드ㅡㅡㅡㅡㅡㅡㅡㅡㅡ//
        float put = 3*timer_pwm_inc.read()/10.0;
        if (put>=0.3) put=0.3;
        float PWM1_1 = PWM1+put;
        float PWM2_1 = PWM2+put;
        if (PWM1_1>=1.0) PWM1_1 = 1.0;
        if (PWM2_1>=1.0) PWM2_1 = 1.0; 
        PWM1 = PWM1_1;
        PWM2 = PWM2_1;
    }
    else{
        //if (a[2] == '2') timer_pwm_inc.start();
        if(ang > middle_angle){         // 오른쪽으로 밀어야 함
            PWM1 = 0.7;
            if(error_free_ang > 40) {
                PWM2 = 0.2;
            }
            else {
                // PWM2 = 0.7 - (error_free_ang)+ Kd*(prev_error_free_ang-error_free_ang)/50.0;
                PWM2 = 0.7 - error_free_ang;
                //pc.printf("free_go_in_turn_right");
            }
        }    
        else if(ang < middle_angle){        //왼쪽으로 말어야함
            if(error_free_ang > 40){
                PWM1 = 0.2;
            }
            else {
                // PWM1 = 0.7 - (error_free_ang)+ Kd*(prev_error_free_ang-error_free_ang)/50.0;
                PWM1 = 0.7 - error_free_ang;
                //pc.printf("free_go_in_turn_left");
            }
            PWM2 = 0.7;
        }
    // printf("%f, %f : ", PWM1_1, PWM2_1);
        // D 제어
        //prev_error_free_ang = error_free_ang;
    }
}
//////////////////////////////////////////////////////////////////////////

void go_back(){
    // dir1 = 1;
    dir1 = 1;    
    dir2 = 0;
    PWM1 = 0.5;
    PWM2 = 0.5;
    back_after = true;
}

void turn_left(){
    dir1 = 1;
    dir2 = 1;
    PWM1 = 0.4;
    PWM2 = 0.4;
}

void turn_right_slow(int error, float Pgain, float Dgain){         // 색 영역 들어갔을 때 좌우 
    dir1 = 0;
    dir2 = 0;
    PWM1 = Pgain*error;
    PWM2 = Pgain*error;
}

void turn_left_slow(int error,float Pgain,float Dgain){          // 색 영역 들어갔을 때 좌우
    dir1 = 1;
    dir2 = 1;
    PWM1 = Pgain*error;
    PWM2 = Pgain*error;
}

void turn_right(){
    dir1 = 0;
    dir2 = 0;
    PWM1 = 0.4;
    PWM2 = 0.4;
}


void red_turning_right(){
    dir1 = 0;
    dir2 = 1;
    PWM1 = 1;
    PWM2 = 0;
}

void red_turning_left(){
    dir1 = 0;
    dir2 = 1;
    PWM1 = 0;
    PWM2 = 1;
}

void turning_right(){
    dir1 = 0;
    dir2 = 1;
    PWM1 = 1.0;
    PWM2 = 0.32;
}

void turning_left(){
    dir1 = 0;
    dir2 = 1;
    PWM1 = 0.32;
    PWM2 = 1.0;
}

void turning_right_blue(){
    dir1 = 0;
    dir2 = 1;
    PWM1 = 0.7;
    PWM2 = 0.45;
}

void turning_left_blue(){
    dir1 = 0;
    dir2 = 1;
    PWM1 = 0.45;
    PWM2 = 0.7;
}

void turn_left_input(float put){
    dir1 = 1;
    dir2 = 1;
    if (put < 85){
        PWM1 = put;
        PWM2 = put;
    }
    else {
        PWM1 = 0.6;
        PWM2 = 0.6;
    }
}

void turn_right_input(float put){
    dir1 = 0;
    dir2 = 0;
    if (put < 85){
        PWM1 = put;
        PWM2 = put;
    }
    else {
        PWM1 = 0.6;
        PWM2 = 0.6;
    }
}

void stop(){
    PWM1=0;
    PWM2=0;
}


void go_straight_slow(){
    dir1 = 0;
    dir2 = 1;
    PWM1 = 0.1;
    PWM2 = 0.1;
}

void go_straight_slow_plus(){
    dir1 = 0;
    dir2 = 1;
    PWM1 = 0.3;
    PWM2 = 0.3;
}

void go_back_slow(){
    dir1 = 1;
    dir2 = 0;
    PWM1 = 0.1;
    PWM2 = 0.1;
}
